---
title: Using Binary Ninja for Vulnerability Research Part 1
date: 2020-10-15
categories: [program analysis]
tags: [binja, vr]
---

# Introduction

Ever since [@cetfor](https://twitter.com/cetfor)'s video on [Auditing system calls for command injection vulnerabilities using Binary Ninja's HLIL](https://www.youtube.com/watch?v=F3uh8DuS0tE&t=447s&ab_channel=HackOvert), I have been wanting to learn more about how you can automate discovering program incorrectness statically.

In this blog, I will go through how we can create a simple memcpy vulnerability scanner for stack based buffer overflow that recieves inputs from stdin with read function.

I should also recommend anyone that wants to learn more about this topic to take [Margin Research PAVR](https://margin.re/trainings/article.aspx?id=6) (Program Analyiss For Vulnerability Research) training by [@Calaquendi44](https://twitter.com/Calaquendi44).

# Requirement

* Binary Ninja personal or commerical license
    * Note that on time of this writing, I am using version `2.4.3072-dev`.
* [Snippets plugin](https://github.com/Vector35/snippets)

# Target

In this simple program, we have dest buffer that is size 0x10. However, we are copying 0x50 bytes from src causing BoF (buffer overflow)

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int main() {
    char dest[0x10] = {0};
    char src[0x50] = {0};

    read(STDIN_FILENO, src, sizeof(src));

    // BoF here. dest is 0x10 bytes but we are trying to write 0x50 bytes.
    memcpy(dest, src, sizeof(src));

    return 0;
}
```
<iframe width="100%" height="800" class="BinjaCloudEmbed" src="https://cloud.binary.ninja/embed/5993099c-ddd9-46cd-b8fc-5f0dfea2aa2b"></iframe>

# Choosing BNIL

On this blog, I choose to use HLIL because it is easiest to script since it is very close to source code. Depending on which analysis you do, switching IL might be a good idea. Most people seem to like to do these kind of analysis on MLIL since HLIL might fold instruction you might be looking for. You can learn more about the difference here [BNIL Overview](https://docs.binary.ninja/dev/bnil-overview.html)

# Goals

1. We will have to get `memcpy` function from the binary view.
2. Then we will get all the functions that are `callers` to `memcpy` function.
3. After that we will iterate through each basic block and check if `read` is in the instruction.
   1. If `read` exists, check if first parameter is `0` (STDIN)
   2. Check if 

Here is how Binary Ninja organizes instructions. [Source by @carste1n](https://twitter.com/carste1n/status/993096105834549248/photo/1)

![](/assets/img/2021-10-15-21-14-11.png)

# Writing our Binja Script in Snippets

## First we will get function object 

```python

```